# Book-Object
![](https://images.velog.io/images/new_wisdom/post/6963f7d6-76c7-44f6-b491-abd40690e08b/image.png)  

> 2021.01.30 ~  

#### 오브젝트(코드로 이해하는 객체지향 설계)를 공부하면서 책에 나온 코드 따라치기 👻

## 01_객체, 설계
데이터와 프로새스를 한 덩어리로 모으는 것은 객체지향 설계로 가는 첫걸음 뿐이다.  
진정한 객체지향 설계는 협력하는 객체들 사이의 의존성을 적절하게 조절함으로 변경에 용이한 설계를 만드는 것이다.

## 02_객체지향 프로그래밍
클래스를 구현하거나 개발된 클래스를 사용할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것이다.  
클래스의 내부와 외부를 구분해야 객체의 자율성이 보장된다.  

#### 자율적인 객체 
* 캡슐화 : 데이터와 기능을 객체 내부로 함께 묶는 것
* 접근 제어 : 외부에서의 접근을 통제 (접근 수정자를 제공한다)  

캡슐화와 접근 제어는 객체를 **퍼블릭 인터페이스(public)** 와 **구현(private, protected)** 으로 나눈다.  
변경 가능성이 있는 세부적 구현 내용을 private 영역 안에 감춘다.  

메시지와 메서드를 구분하는 것으로부터 다형성의 개념이 시작된다.  

### 상속과 다형성  
코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다.  
클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.   
다르면 다를수록 코드를 이해하기 어려워지지만, 더 유연해지고 확장 가능해진다.  

#### 차이에 의한 프로그래밍
상속을 이용하여 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법

#### 업캐스팅
상속으로 인해 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있다.  
때문에 부모 클래스 대신 사용될 수도 있다.   
인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다.   

#### 다형성  
객체지향 프로그램의 컴파일 시간 의존성과 실행시간 의존성이 다를 수 있다는 사실을 기반으로 한다.   
다형성은 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력이다.   
클래스를 상속받는 것 만이 다형성을 구형할 수 있는 유일한 방법은 아니다.  

* 구현 상속 : 순수하게 코드를 재사용할 목적  
* 인터페이스 상속 : 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것   

인터페이스만을 공유하고 싶을 때는 인터페이스를 이용하라.  

#### 추상화의 장점
* 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다.   
* 추상화를 이용해 상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.  

### 코드 재사용  
#### 합성   
코드 재사용을 위해 상속보다는 합성을 하라.
합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법이다.  
상속은 캡슐화를 위반하며 설계를 유연하지 못하게 만든다.  
인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법  

## 03_역할, 책임, 협력
객체는 자신이 맡은 책임을 수행하는 데 필요한 정보를 알고 있을 책임이 있다.  
객체는 자신이 할 수 없는 작업을 도와줄 객체를 알고 있을 책임이 있다.  

#### 메시지가 객체를 결정한다.  
* 객체가 최소한의 인터페이스를 가질 수 있게 되다.
* 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다.  

#### 객체 VS 역할
협력에 참여하는 후보가 여러 종류의 객체에 의해 수행될 필요가 있다면 그 후보는 역할이 되지만,  
단지 한 종류의 객체만이 협력에 참여할 필요가 있다면 후보는 객체가 된다.  

객체에 관해 생각할 때 '이 객체가 무슨 역할을 수행해야 하는가?'를 자문하자.  

#### 역할과 추상화 
역할은 공통의 책임을 바탕으로 객체의 종류를 숨겨 객체의 추상화를 돕는다.  

역할은 객체가 협력에 참여하는 잠시 동안에만 존재하는 일시적인 개념이다.  
객체는 다양한 역할을 가질 수 있다.  
하지만 특정 협력 안에서는 일시적으로 오직 하나의 역할만이 보여진다.  

## 04_설계 품질과 트레이드오프
객체 지향 설계에서 두 가지 방법으로 시스템을 객체로 분할할 수 있다.
* 상태(데이터)를 분할의 중심축으로 삼는 방법 
* 책임을 분할의 중심축으로 삼는 방법

상태는 구현에 속하고, 책임은 인터페이스에 속한다.  
데이터에 초점을 맞추는 설계는 상태 변경을 할 때 인터페이스의 변경을 초래하며,   
인터페이스에 의존하는 모든 객체에세 변경의 영향이 퍼진다.

변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도이다.  
결합도는 한 모듈이 변경되기 위해 다른 모듈의 변경을 요구하는 정도이다.  
클래스의 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 한다.  
캡슐화는 결합도와 응집도에 큰 영향을 미친다.  
객체는 자신이 어떤 데이터를 가지고 있는지 내부에 캡슐화하고 공개해서는 안된다. (getter, setter도 마찬가지)

#### 스스로 자신의 데이터를 책임지는 객체
"이 객체가 어떤 데이터를 포함해야 하는가?"
"이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?"

접근자와 수정자가 `public`이면 캡슐화라고 말할 수 없다.

## 05_책임 할당하기
* 데이터보다 행동을 먼저 결정
* 협력이라는 문맥 안에서 책임을 결정

#### 데이터보다 행동을 먼저 결정하라
객체는 데이터가 아닌 외부에 제공하는 행동이 중요하다.  
적절한 객체에게 적절한 책임을 할당하라.

#### 협력이라는 문맥 안에서 책임을 결정하라
객체에게 할당된 책임이 협력에 어울리지 않는다면 그 책임은 나쁜 것이다.  
객체 입장에서 책임이 어색하더라도 협력에 적합하면 그 책임은 좋은 것이다.  
협력에 적합한 책임이란 메시지 수신자가 아니라 메시지 전송자에게 적합한 책임을 의미한다.  
메시지를 결정한 후 객체를 선택해야 한다.  
"메시지를 전송해야 하는데 누구에게 전송해야 하지?"
클라이언트가 전송할 메시지를 결정한 후에야 비로소 객체의 상태를 저장하는 데 필요한 내부 데이터에 관해 고민한다.  

#### 책임 주도 설계
* 시스템이 사용자에세 제공해야 하는 기능인 시스템 책임을 파악한다.
* 시스템 책임을 더 작은 책임으로 분할한다.
* 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
* 객체가 책임을 수행하는 도중 다른 객체이 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
* 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다.


#### 책임 할당을 위한 GRASP 패턴
##### 도메인 개념에서 출발하기
* 도메인 개념을 정리하는 데 너무 많은 시간을 들이지 말라
* 올바른 도메인 모델이란 존재하지 않는다.

애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각부터 시작한다.  
- "메시지를 전송할 객체는 무엇을 원하는가?"  
- "메시지를 수신할 적합한 객체는 누구인가?"    

##### 정보 전문가 패턴(INFORMATION EXPERT)
: 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것   
객체가 자신이 소유하고 있는 정보와 관련된 작업을 수행  
(정보를 알고 있다고 해서 가지고 있을 필요는 없다)

##### 낮은 결합도 패턴(LOW COUPLING)
의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시킴  

##### 높은 응집도 패턴(HIGH COHESION)
복잡성을 관리할 수 있는 수준으로 유지  

##### 창조자 패턴(CREATOR)
객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침 제공  
객체 A를 생성해야 할 때 아래 조건을 최대한 만족하는 B에게 객체 생성 책임을 할당하라
* B가 A 객체를 포함하거나 참조한다.
* B가 A 객체를 기록한다.
* B가 A 객체를 긴밀하게 사용한다.
* B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다. (이는 B가 A에 대한 정보 전문가)

이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영행을 미치지 않는다.  

#### 클래스 안에서 변경의 이유를 찾는 법
1. 인스턴스 변수가 초기화 되는 시점을 살펴본다. 
응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다.  
따라서 함께 초기화되는 속성을 기준으로 코드를 분리해야 한다.  

2. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴본다.  
모든 메서드가 객체의 모든 속성을 사용하면 응집도가 높은 것이라고 볼 수 있지만,  
메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다.  
응집도를 높이기 위해 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다. 
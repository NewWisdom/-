# Book-Object
![](https://images.velog.io/images/new_wisdom/post/6963f7d6-76c7-44f6-b491-abd40690e08b/image.png)  

> 2021.01.30 ~  

#### 오브젝트(코드로 이해하는 객체지향 설계)를 공부하면서 책에 나온 코드 따라치기 👻

## 01_객체, 설계
데이터와 프로새스를 한 덩어리로 모으는 것은 객체지향 설계로 가는 첫걸음 뿐이다.  
진정한 객체지향 설계는 협력하는 객체들 사이의 의존성을 적절하게 조절함으로 변경에 용이한 설계를 만드는 것이다.

## 02_객체지향 프로그래밍
클래스를 구현하거나 개발된 클래스를 사용할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것이다.  
클래스의 내부와 외부를 구분해야 객체의 자율성이 보장된다.  

#### 자율적인 객체 
* 캡슐화 : 데이터와 기능을 객체 내부로 함께 묶는 것
* 접근 제어 : 외부에서의 접근을 통제 (접근 수정자를 제공한다)  

캡슐화와 접근 제어는 객체를 **퍼블릭 인터페이스(public)** 와 **구현(private, protected)** 으로 나눈다.  
변경 가능성이 있는 세부적 구현 내용을 private 영역 안에 감춘다.  

메시지와 메서드를 구분하는 것으로부터 다형성의 개념이 시작된다.  

### 상속과 다형성  
코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다.  
클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.   
다르면 다를수록 코드를 이해하기 어려워지지만, 더 유연해지고 확장 가능해진다.  

#### 차이에 의한 프로그래밍
상속을 이용하여 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법

#### 업캐스팅
상속으로 인해 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있다.  
때문에 부모 클래스 대신 사용될 수도 있다.   
인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다.   

#### 다형성  
객체지향 프로그램의 컴파일 시간 의존성과 실행시간 의존성이 다를 수 있다는 사실을 기반으로 한다.   
다형성은 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력이다.   
클래스를 상속받는 것 만이 다형성을 구형할 수 있는 유일한 방법은 아니다.  

* 구현 상속 : 순수하게 코드를 재사용할 목적  
* 인터페이스 상속 : 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것   

인터페이스만을 공유하고 싶을 때는 인터페이스를 이용하라.  

#### 추상화의 장점
* 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다.   
* 추상화를 이용해 상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.  

### 코드 재사용  
#### 합성   
코드 재사용을 위해 상속보다는 합성을 하라.
합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법이다.  
상속은 캡슐화를 위반하며 설계를 유연하지 못하게 만든다.  
인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법  

## 03_역할, 책임, 협력
객체는 자신이 맡은 책임을 수행하는 데 필요한 정보를 알고 있을 책임이 있다.  
객체는 자신이 할 수 없는 작업을 도와줄 객체를 알고 있을 책임이 있다.  

#### 메시지가 객체를 결정한다.  
* 객체가 최소한의 인터페이스를 가질 수 있게 되다.
* 객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다.  

#### 객체 VS 역할
협력에 참여하는 후보가 여러 종류의 객체에 의해 수행될 필요가 있다면 그 후보는 역할이 되지만,  
단지 한 종류의 객체만이 협력에 참여할 필요가 있다면 후보는 객체가 된다.  

객체에 관해 생각할 때 '이 객체가 무슨 역할을 수행해야 하는가?'를 자문하자.  

#### 역할과 추상화 
역할은 공통의 책임을 바탕으로 객체의 종류를 숨겨 객체의 추상화를 돕는다.  

역할은 객체가 협력에 참여하는 잠시 동안에만 존재하는 일시적인 개념이다.  
객체는 다양한 역할을 가질 수 있다.  
하지만 특정 협력 안에서는 일시적으로 오직 하나의 역할만이 보여진다.  

## 04_설계 품질과 트레이드오프
객체 지향 설계에서 두 가지 방법으로 시스템을 객체로 분할할 수 있다.
* 상태(데이터)를 분할의 중심축으로 삼는 방법 
* 책임을 분할의 중심축으로 삼는 방법

상태는 구현에 속하고, 책임은 인터페이스에 속한다.  
데이터에 초점을 맞추는 설계는 상태 변경을 할 때 인터페이스의 변경을 초래하며,   
인터페이스에 의존하는 모든 객체에세 변경의 영향이 퍼진다.

변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도이다.  
결합도는 한 모듈이 변경되기 위해 다른 모듈의 변경을 요구하는 정도이다.  
클래스의 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 한다.  
캡슐화는 결합도와 응집도에 큰 영향을 미친다.  
객체는 자신이 어떤 데이터를 가지고 있는지 내부에 캡슐화하고 공개해서는 안된다. (getter, setter도 마찬가지)

#### 스스로 자신의 데이터를 책임지는 객체
"이 객체가 어떤 데이터를 포함해야 하는가?"
"이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?"

접근자와 수정자가 `public`이면 캡슐화라고 말할 수 없다.
